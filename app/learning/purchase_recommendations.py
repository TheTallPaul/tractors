# NOTE: this file was generated by an LLM model and I have made only minor modifications
# The purpose is to serve as a mock, not to highlight my miniscule machine learning skills
# (and this implementation would **not** be a good advertisement of skills even if I had them)

from os import makedirs, path
from pydantic import BaseModel
from sqlmodel import Session, select
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import LabelEncoder
import numpy as np
import pickle

from app.database import engine, ConditionsHistory, Sales, Deliveries, TractorParts
from app.models import PartOrderRecommendation

MODEL_DIR = "app/learning/models"
makedirs(MODEL_DIR, exist_ok=True)

class PartOrderPredictor:
    def __init__(self) -> None:
        self.model_quantity = RandomForestRegressor(n_estimators=100, random_state=42)
        self.model_supplier = RandomForestRegressor(n_estimators=100, random_state=42)
        self.label_encoder = LabelEncoder()

    def train(self) -> None:
        print("🏃🏃🏃 Begin training the model 🏃🏃🏃")
        # Fetch historical data
        with Session(engine) as session:
            sales = session.exec(select(Sales)).all()
            deliveries = session.exec(select(Deliveries)).all()
            conditions = session.exec(select(ConditionsHistory)).all()
            tractor_parts = session.exec(select(TractorParts)).all()

        print(f"Sales count: {len(sales)}, Deliveries count: {len(deliveries)}, Conditions count: {len(conditions)}")

        # Create a map of which parts are required for each tractor
        tractor_parts_map = {tp.tractor_id: [] for tp in tractor_parts}
        for tp in tractor_parts:
            tractor_parts_map[tp.tractor_id].append((tp.part_serial, tp.quantity_required))

        # Transform data
        data = []
        labels_quantity = []
        labels_supplier = []

        for sale in sales:
            matching_condition = next(
                (c for c in conditions if c.conditions_date == sale.sales_date and c.region_id == sale.region_id), None)

            # Find which parts are needed for this sale
            if sale.tractor_id in tractor_parts_map:
                required_parts = tractor_parts_map[sale.tractor_id]
                for part_serial, qty_required in required_parts:
                    # Find past deliveries for this part
                    matching_delivery = next(
                        (d for d in deliveries if d.delivery_date == sale.sales_date and d.part_serial == part_serial), 
                        None
                    )

                    if matching_condition and matching_delivery:
                        data.append([
                            sale.sales_date.month,           # Month
                            hash(part_serial) % 100,         # Part Serial (hashed for ML)
                            qty_required,                    # Parts required per tractor
                            matching_condition.temperature,  # Weather
                            matching_condition.precipitation # Precipitation
                        ])
                        labels_quantity.append(qty_required)
                        labels_supplier.append(matching_delivery.supplier_id)

        # Convert supplier IDs to labels for training
        supplier_labels = self.label_encoder.fit_transform(labels_supplier)

        # Train models
        self.model_quantity.fit(data, labels_quantity)
        self.model_supplier.fit(data, supplier_labels)

        # Save models
        with open(path.join(MODEL_DIR, "model_quantity.pkl"), "wb") as f:
            pickle.dump(self.model_quantity, f)
        with open(path.join(MODEL_DIR, "model_supplier.pkl"), "wb") as f:
            pickle.dump(self.model_supplier, f)
        with open(path.join(MODEL_DIR, "label_encoder.pkl"), "wb") as f:
            pickle.dump(self.label_encoder, f)

        print("🏁🏁🏁 Training complete 🏁🏁🏁")
        print("Models saved to disk: model_quantity.pkl, model_supplier.pkl, label_encoder.pkl")

    def predict(
            self, 
            month: int, 
            part_serial: str, 
            current_quantity: int, 
            avg_temp: int, 
            precipitation: int,
        ) -> PartOrderRecommendation:
        # Load models if not already in memory
        with open(path.join(MODEL_DIR, "model_quantity.pkl"), "rb") as f:
            self.model_quantity = pickle.load(f)
        with open(path.join(MODEL_DIR, "model_supplier.pkl"), "rb") as f:
            self.model_supplier = pickle.load(f)
        with open(path.join(MODEL_DIR, "label_encoder.pkl"), "rb") as f:
            self.label_encoder = pickle.load(f)

        if any(model is None for model in (self.model_quantity, self.model_supplier, self.label_encoder)):
            raise Exception("Models not loaded")

        # Predict quantity to order
        input_data = np.array([[month, hash(part_serial) % 100, current_quantity, avg_temp, precipitation]])
        quantity_to_order = self.model_quantity.predict(input_data)[0]

        # Predict best supplier
        predicted_supplier_label = self.model_supplier.predict(input_data)[0]
        supplier_id = self.label_encoder.inverse_transform([int(predicted_supplier_label)])[0]

        # Compute confidence
        confidence = max(0, min(1, 1 - abs(quantity_to_order - current_quantity) / (current_quantity + 1e-6)))

        return {
            "quantity_to_order": int(quantity_to_order),
            "supplier_id": int(supplier_id),
            "confidence": round(confidence, 2)
        }
